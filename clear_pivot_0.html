<html> <body> <script>
// TexMat &#
/*---------------------------- Options ---------------------------*/
var width  = 10;
var height = 10;
var pivot_val = 0;

/*---------------------------- Document -------------------------*/
var canvas = document.createElement('canvas');
    canvas.width  = width;
    canvas.height = height;

var gl = canvas.getContext('webgl');
var ext = gl.getExtension('WEBGL_draw_buffers');
    gl.getExtension('OES_texture_float');
    gl.viewport(0, 0, width, height);

/*---------------------------- Shader ----------------------------*/
var vertex_shader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertex_shader,`
        attribute vec2 vertex_attrib;
        attribute vec2 uv_attrib;
        varying vec2 uv;
        void main(void) {
            uv = uv_attrib;
            gl_Position = vec4(vertex_attrib, 0., 1.);}`);
    gl.compileShader(vertex_shader);

var fragment_shader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragment_shader, `
        precision mediump float;
        uniform float pivot;
        uniform float W;
        uniform float H;

        uniform sampler2D tex;
        varying vec2 uv;

        float get(float i, float j) {
            return texture2D(tex, vec2( (j+.5)/W, (i+.5)/H )).x;}

        void main(void) {  
            float I = uv.y*H - .5;
            float J = uv.x*W - .5; 
            
            float p_val    = get(pivot, pivot);
            float elim_val = get(    I, pivot);

            float up_val   = get(pivot,      J);
            float this_val = get(    I,      J);
            
            if (I > pivot) { 
                float new_val = this_val - up_val*elim_val/p_val;
                gl_FragColor.r = new_val;}  
            else {
                gl_FragColor.r = this_val;}

         }`); 
    gl.compileShader(fragment_shader);

var shader_program = gl.createProgram();
    gl.attachShader(shader_program, vertex_shader);
    gl.attachShader(shader_program, fragment_shader);
    gl.linkProgram(shader_program); gl.useProgram(shader_program);

var tex_uniform   = gl.getUniformLocation(shader_program,'tex');
var pivot_uniform = gl.getUniformLocation(shader_program, 'pivot'); 
var width_uniform = gl.getUniformLocation(shader_program, 'W'); 
var height_uniform = gl.getUniformLocation(shader_program, 'H')

var vertex_attrib = gl.getAttribLocation(shader_program,'vertex_attrib');
var uv_attrib     = gl.getAttribLocation(shader_program,'uv_attrib');

/*--------------------------- Surface -------------------------------*/
var vertex_array = new Float32Array(
    [-1,1,0,1, -1,-1,0,0, 1,1,1,1,  1,-1,1,0]);
    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
    gl.bufferData(gl.ARRAY_BUFFER, vertex_array, gl.STATIC_DRAW);
    gl.enableVertexAttribArray(vertex_attrib);
    gl.enableVertexAttribArray(uv_attrib);
    gl.vertexAttribPointer(vertex_attrib, 2, gl.FLOAT, false, 4*4, 0); 
    gl.vertexAttribPointer(uv_attrib,     2, gl.FLOAT, false, 4*4, 2*4); 

var frame_buffer_0 = gl.createFramebuffer();
var tex_data_0 = lin4space(width*height);
var tex_obj_0 = gl.createTexture();
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(  gl.TEXTURE_2D, tex_obj_0);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,
                  width, height, 0, gl.RGBA, gl.FLOAT, null);

var frame_buffer_1 = gl.createFramebuffer();
var tex_data_1 = new Float32Array(4*width*height).fill(1);
var tex_obj_1 = gl.createTexture();
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(  gl.TEXTURE_2D, tex_obj_1);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,
                  width, height, 0, gl.RGBA, gl.FLOAT, null);

gl.activeTexture(gl.TEXTURE0);
gl.uniform1f(width_uniform, width);
gl.uniform1f(height_uniform, height);
gl.bindFramebuffer(gl.FRAMEBUFFER, frame_buffer_0);

document.write('Texture-Matrix: '+ width +' by '+height + '<br/>' + 
    'clear under pivot test <br/><br/> initial data: <br/>');  
print(tex_data_0, 0); 

/*-------------------------- Draw/Read -------------------------------*/
function row_clear(piv) {
    gl.uniform1f(pivot_uniform, piv);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,
              width, height, 0, gl.RGBA, gl.FLOAT, tex_data_0);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, 
        gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex_obj_1, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    gl.readPixels(0,0, width,height, gl.RGBA, gl.FLOAT, tex_data_1);
   
    document.write('pivot: ' + piv + '<br/>');    print(tex_data_1, 0);}

for (let i = 0; i < height-1; i++) {
    row_clear(i);}

/*-------------------------- Utility Functions ------------------------*/
function random(size) {
    let new_array = new Float32Array(size);
    for (let i = 0; i < size; i++) {
        new_array[i] = Math.random();}
    return new_array;}

function print(data, offset = 0) {
    let dim = Math.sqrt(data.length/4);
    let string = '';
    for (let i = 0; i < dim; i++) {
        for (let j = 0; j < dim; j++) {
            string += data[4*(dim*i+j)+offset].toFixed(2) + ' , ';}
        string += '<br/>';}
    document.write(string + '<br/>');}

function list(data) {
    let string = '';
    for (let i = 0; i < data.length; i++) {
        string += data[i].toFixed(4) + '<br>';}
    document.write(string);}

function lin4space(size) {
    let data = [];
    for (let i = 1; i < size+1; i++) {
        data.push(i,i,i,i);}
    return new Float32Array(data);}

function copy() {
    for (let i = 0; i < 4*width*height; i++) {
        tex_data_0[i] = tex_data_1[i]; }}

</script> </body> </html>